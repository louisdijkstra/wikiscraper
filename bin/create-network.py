#!/usr/bin/env python
from __future__ import print_function, division
from optparse import OptionParser
import os
import sys
import networkx as nx
import pandas as pd
from pandas import DataFrame
from pandas import Series

__author__ = "Louis Dijkstra"

usage = """%prog <input.tsv>

	<input.tsv>		input file generated by scrape-top-edits-for-users.py
	<output.gexf> 	output file that will contain the network data (suitable for Gephy)

Creates a network where the articles are nodes. The weighted edges
represent the number of users that contributed to both articles. 
"""

def main():

	parser = OptionParser(usage=usage)	
	parser.add_option("-l", action="store", dest="article_file", default=None, 
							help="TSV file with column 'title', 'eb_estimate', and 'rank'. The eb_estimate is added a node attribute.")
	parser.add_option("-m", action="store", dest="min_weight", default=0, type=int, 
				  			help="Minimal weight for the edges to be taken into account (Default: no minimum)")
	parser.add_option("-t", action="store", dest="top", default=None, type=int, 
				  			help="Top number of articles are added (based on rank).")
	parser.add_option("-u", action="store", dest="min_users", default=0, type=int, 
				  			help="Minimal number of editors for an article to be taken into account (Default: no minimum)")
	parser.add_option("-v", action="store_true", dest="verbose", default=False, 
				  			help="verbose.")
	(options, args) = parser.parse_args()
	
	# process arguments
	if (len(args)!=2):
		parser.print_help()
		return 1

	inputfilename  = args[0]
	outputfilename = args[1]

	article_list = None

	if options.article_file != None: 
		article_df = DataFrame.from_csv(options.article_file, sep='\t', index_col=False)
		article_list = article_df.title.unique()

	# read in the input file 
	df = DataFrame.from_csv(inputfilename, sep='\t', index_col=False)

	# get the unique users in the data frame
	unique_users = df.user.unique()

	# get the unique articles for which the number of users 
	# that contributed exceeds the given minimum (see option -u)
	unique_articles = df.groupby('title').agg(['count'])
	unique_articles = unique_articles[unique_articles[('user', 'count')] >= options.min_users]

	if article_list is not None: 
		unique_articles = unique_articles[unique_articles.index.isin(article_list)]
		
	# initialize the network
	G = nx.Graph()

	# add the articles as nodes to the network
	for article in list(unique_articles.index):
		G.add_node(article)

	n_users = len(unique_users)

	# walk through every single user and go through his/her contributions
	for i, username in enumerate(unique_users): 
		if options.verbose: 
			print('Processing user no. %d of %d\t(%.2f %%)\tname: %s'%(i+1, n_users, float(i+1)/float(n_users) * 100, username))

		df_user = df[df.user == username] 

		articles = list(df_user.title) # get the articles for this user

		if article_list is not None: 
			articles = list(set(articles).intersection(article_list))

		# add the edges
		for i in range(len(articles) - 1): 
			article1 = articles[i]
			if not article1 in unique_articles.index: 
				continue 

			for j in range(i+1, len(articles)): 
				article2 = articles[j]
				if not article2 in unique_articles.index: 
					continue 
				if G.has_edge(article1, article2):
					G[article1][article2]['weight'] += 1
				else:
					G.add_edge(article1, article2, weight=1)

	print("Total of %d nodes and %d edges were added" % (G.number_of_nodes(), G.number_of_edges()))
	
	# walk through the edges and see whether their weight is sufficient
	for u,v,a in G.edges(data=True):
		if a['weight'] < options.min_weight: 
			G.remove_edge(u,v)

	nx.write_gexf(G, outputfilename)
	
if __name__ == '__main__':
	sys.exit(main())